#!/usr/bin/env python

import struct
import sys
import json
import urllib2
import zipfile
import os
import logging
import Queue

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s %(message)s',
                    filename=os.path.realpath(__file__)+'.log',
                    filemode='a+')

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import msvcrt
    import win32print
    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
    platform = "win32"
else:
    platform = "other"
    import cups


class PrintHost:

    c_path = os.path.dirname(os.path.realpath(__file__))+os.sep
    file = ""
    raw = ""
    real_name = ""
    printer = ""
    queue = Queue.Queue()
    # Thread that reads messages from the web.

    def read_input(self):
        self.send_message("LOG", "Started reading input")
        text = ""
        # Number of retries after quitting
        interactions = 2

        while text == "":
            self.send_message("LOG", "Waiting for input")
            # Read the message length (first 4 bytes).

            text_length_bytes = sys.stdin.read(4)
            if len(text_length_bytes) > 0:
                # Unpack message length as 4 byte integer.
                self.send_message("LOG", "Reading the input")
                text_length = struct.unpack("i", text_length_bytes)[0]
                self.send_message("LOG", "Reading the length")
                text = sys.stdin.read(text_length)
                try:
                    logging.info(text + "\n\n\n")
                    self.queue.put(text)
                    self.process_message()
                except:
                    import traceback
                    logging.info(sys.exc_info())
                    logging.info(traceback.format_exc())
                break
            # Reduce remaining interactions
            interactions -= 1
            if interactions == 0:
                sys.exit(0)
            else:
                self.read_input()
        sys.exit(0)

    # Message Processor
    def process_message(self):
        while not self.queue.empty():
            message = self.queue.get_nowait()
            self.send_message("LOG", "process_message -> Processing received message: " + message)
            content = json.loads(message)
            content_keys = content.keys()
            if "printer" in content_keys:  # user sent a print intent
                self.printer = content["printer"]
                self.file = content["file"]
                self.send_message("LOG", "process_message -> Try Printing at " + self.printer)
                try:
                    is_zip = self.get_file()
                    if is_zip:
                        self.unzip()
                    self.send_to_printer()
                    self.send_message("LOG", "process_message -> Printed at " + self.printer)
                except (IOError, RuntimeError, OSError):
                    self.send_message("ERROR", sys.exc_info())
                    sys.exit(1)
            elif "list" in content_keys:
                logging.info('here')
                try:
                    self.enum_printers((4, 2))
                except:
                    import traceback
                    logging.info(traceback.format_exc())
                    logging.info(sys.exc_info()[0] + "\n" + sys.exc_info()[2].tb_frame.f_code.co_filename + "\n" + sys.exc_info()[2].tb_lineno)
                    sys.exit(1)
            else:
                self.send_message("LOG", "There is no method implemented to handle:" + message)
                sys.exit(0)

    def enum_printers(self, tpl):
        logging.info("enum")
        for i in tpl:
            logging.info(i)
            try:
                printer_list = win32print.EnumPrinters(i)
                logging.info(printer_list)
                for item in printer_list:
                    logging.info(item)
                    self.send_message("printer", item[2])
            except (IOError, RuntimeError, OSError):
                import traceback
                logging.info(traceback.format_exc())
                logging.info(sys.exc_info()[0] + "\n" + sys.exc_info()[2].tb_frame.f_code.co_filename + "\n" + sys.exc_info()[2].tb_lineno)
                sys.exit(1)
                sys.exit(1)

    def get_file(self):
        file_type = self.file.split(".")[-1]
        self.real_name = self.file.split(".")[-2].split("/")[-1]
        self.send_message("LOG", "get_file -> Starting download of " + self.file)

        download_file = urllib2.urlopen(self.file)
        self.send_message("LOG", "get_file -> Download setup done")

        dl_file = self.c_path + "print."+file_type  # Set local zip file name will be written at the installation folder
        self.send_message("LOG", "get_file -> Download file set as: {0}".format(dl_file))

        fo = open(dl_file, "wb+")  # Open the destination file for writing in binary mode (clears the previous content)
        self.send_message("LOG", "get_file -> Opening file for writing")
        self.raw = ""
        while True:  # waiting to finish the download
            data = download_file.read(8192)
            if not data:
                break
            else:
                try:
                    fo.write(data)  # write chunk to the zip file
                    self.raw += data
                except IOError:
                    self.send_message("ERROR", sys.exc_info())
                    sys.exit(1)
        self.file = dl_file
        self.send_message("LOG", "get_file -> Done downloading file")
        return True if file_type == "zip" else False

    def unzip(self):
        print_file = self.c_path + "print.txt"
        self.send_message("LOG", "unzip -> File set as: {0}".format(self.file))
        self.raw = ""
        if zipfile.is_zipfile(self.file):
            to_unzip = zipfile.ZipFile(self.file)
            for name in to_unzip.namelist():
                try:
                    fo = open(print_file, "wb")
                    self.raw = to_unzip.read(name)
                    fo.write(self.raw)
                    fo.close()
                except (IOError, RuntimeError, AssertionError, OSError):
                    self.send_message("LOG", "unzip -> ERROR: Cannot Open zip file")
                    logging.info(sys.exc_info())
                    self.send_message("ERROR", sys.exc_info())
                    sys.exit(1)
        else:
            logging.info(zipfile.ZipInfo(self.file))
            sys.exit(5)
        self.file = print_file

    def send_to_printer(self):
        doc_name = "PyJob_" + self.real_name  # create a name for the job
        self.send_message("LOG", "send_to_printer -> Print job setup")
        d_printer = win32print.OpenPrinter(self.printer)  # connect to the selected printer
        self.send_message("LOG", "send_to_printer -> Create print job document: " + doc_name)
        try:
            win32print.StartDocPrinter(d_printer, 1, (doc_name, None, "RAW"))
        except RuntimeError:
            self.send_message("ERROR", sys.exc_info())
        self.send_message("LOG", "send_to_printer -> Create print job page")
        win32print.StartPagePrinter(d_printer)
        self.send_message("LOG", "send_to_printer -> Put print file content to page" + self.file)
        self.send_message("LOG", "send_to_printer -> Print File contents: \n" + self.raw)
        win32print.WritePrinter(d_printer, self.raw)
        self.send_message("LOG", "send_to_printer -> Close page")
        win32print.EndPagePrinter(d_printer)
        self.send_message("LOG", "send_to_printer -> Close Doc")
        win32print.EndDocPrinter(d_printer)
        win32print.ClosePrinter(d_printer)
        self.send_message("LOG", "send_to_printer -> print Job done")
        self.send_message("EXIT", "EOF")
        sys.exit(0)

    @staticmethod
    def send_message(msg_type, msg):

        if msg_type == "ERROR":
            msg = "{\"Error\": \"An error has occurred:\n" + repr(msg) + "\"}"
        elif msg_type == "EXIT":
            sys.stdin.close()
        else:
            msg = json.dumps({msg_type.lower(): msg})
            logging.info(msg)
        sys.stdout.write(struct.pack("I", len(msg)))
        sys.stdout.write(msg)
        sys.stdout.flush()

    def __init__(self):
        self.send_message("LOG", "Main -> Started native client")
        self.read_input()
        sys.exit(0)


def main():
    PrintHost()
    sys.exit(0)

if __name__ == "__main__":
    main()


#
# a #### #! / usr /b in/ e
# nv python
#
# import struct
# import sys
# import win32print
# import json
# import urllib2
# import zipfile
#
# # On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# # to avoid unwanted modifications of the input/output streams.
# if sys.platform == "win32":
#     import os
#     import msvcrt
#
#     msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
#     msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
#     platform = "win32"
# else:
#     platform = "other"
#
# c_path = os.path.dirname(os.path.realpath(__file__))+os.sep
#
#
# # Thread that reads messages from the web.
# def read_input():
#
#     send_message("LOG", "Started reading input")
#     text = ""
#     # Number of retries after quitting
#     interactions = 2
#
#     while text == "":
#         send_message("LOG", "Waiting for input")
#         # Read the message length (first 4 bytes).
#         text_length_bytes = sys.stdin.read(4)
#
#         if len(text_length_bytes) > 0:
#             send_message("LOG", "Reading input")
#             # Unpack message length as 4 byte integer.
#             text_length = struct.unpack("i", text_length_bytes)[0]
#
#             # Read the text (JSON object) of the message.
#             text = sys.stdin.read(text_length)
#             send_message("LOG", "{received:" + text + "}")
#             process_message(text)
#
#         # Reduce remaining interactions
#         interactions -= 1
#         print(interactions)
#         if interactions == 0:
#             sys.exit(0)
#         else:
#             read_input()
#     sys.exit(0)
#
#
# # Message Processor
# def process_message(message):
#     send_message("LOG", "process_message -> Processing received message: " + message)
#     content = json.loads(message)
#
#     if printer:
#         # printer is the user selected printer
#         printer = content["printer"]
#         # toPrint is the file url
#         file_url = content["file"]
#         send_message("LOG", "process_message -> printer: " + printer)
#         send_message("LOG", "process_message -> file: " + file_url)
#         send_message("LOG", "process_message -> Try Printing at " + printer)
#         try:
#             send_message("LOG", "process_message -> Will Printing at " + printer)
#             prn_file = get_file(file_url)
#             if prn_file['is_zip']:
#                 prn_file = unzip(prn_file)
#             prn_file['printer'] = printer
#             send_to_printer(prn_file)
#             # print_it(printer, to_print)
#             send_message("LOG", "process_message -> Printed at " + printer)
#         except (IOError, RuntimeError, OSError):
#             send_message("ERROR", sys.exc_info())
#             sys.exit(1)
#     else:
#         send_message("LOG", "lista")
#     sys.exit(0)
#
#
# def get_file(file_url):
#     file_type = file_url.split('.')[-1]
#     real_name = file_url.split('.')[-2].split("/")[-1]
#     send_message("LOG", "get_file -> Starting download of " + file_url)
#     # open url connection to download file
#     download_file = urllib2.urlopen(file_url)
#     send_message("LOG", "get_file -> Download setup done")
#     # Set local zip file name will be written at the installation folder
#     dl_file = c_path + "print."+file_type
#     send_message("LOG", "get_file -> Download file set as: {0}".format(dl_file))
#     # Open the destination file for writing (clears the previous content)
#     fo = open(dl_file, "wb+")
#     send_message("LOG", "get_file -> Opening file for writing")
#     raw = ""
#     while True:  # waiting to finish the download
#         send_message("LOG", "get_file -> Downloading data ...")
#         data = download_file.read(8192)
#         send_message("LOG", "get_file -> Getting a 1Kb chunk ...")
#         if not data:
#             send_message("LOG", "get_file -> No data stream ....")
#             break
#         else:
#             send_message("LOG", "get_file -> Try: Write to file")
#             try:
#                 fo.write(data)  # write chunk to the zip file
#                 raw += data
#                 send_message("LOG", "get_file -> Writing to file")
#             except IOError:
#                 send_message("ERROR", sys.exc_info())
#                 sys.exit(1)
#
#     send_message("LOG", "get_file -> Done downloading file")
#     is_zip = True if file_type == 'zip' else False
#     result = {'file': dl_file, 'raw': raw, 'is_zip': is_zip, 'real_name': real_name}
#
#     return result
#
#
# def unzip(prn_file):
#     print_file = c_path + "print.txt"
#     send_message("LOG", "unzip -> File set as: {0}".format(prn_file['file']))
#     raw = ''
#     try:
#         send_message("LOG", "unzip -> Try: Unzip the file: {0}".format(prn_file['file']))
#         send_message("LOG", "unzip -> Try: Open zip file")
#         if zipfile.is_zipfile(prn_file['file']):
#             to_unzip = zipfile.ZipFile(prn_file['file'])
#         else:
#             send_message("LOG", "unzip -> ERROR: Can't Open zip file")
#             sys.exit(1)
#         for name in to_unzip.namelist():  # interact with the list of files at zip archive
#             fo = open(print_file, "wb")
#             raw = to_unzip.read(name)  # open the print file for writing (clears the previous content)
#             fo.write(print_file)  # write the result of the unzipping
#             fo.close()  # close the file object
#     except (IOError, RuntimeError, AssertionError, OSError):
#         send_message("ERROR", sys.exc_info())
#         send_message("LOG", "unzip -> A error has occurred")
#         sys.exit(1)
#     result = {'file': print_file, 'raw': raw, 'is_zip': prn_file['is_zip'], 'real_name': prn_file['real_name']}
#     return result
#
#
# def send_to_printer(prn_file):
#     doc_name = "Pyprint" + prn_file['real_name']  # create a name for the job
#     send_message("LOG", "send_to_printer -> Print job setup")
#     printer = win32print.OpenPrinter(prn_file['printer'])  # connect to the selected printer
#     send_message("LOG", "send_to_printer -> Create print job document: " + doc_name)
#     try:
#         win32print.StartDocPrinter(printer, 1, (doc_name, None, "RAW"))
#     except RuntimeError:
#         send_message("ERROR", sys.exc_info())
#     send_message("LOG", "send_to_printer -> Create print job page")
#     win32print.StartPagePrinter(printer)
#     send_message("LOG", "send_to_printer -> Put print file content to page" + prn_file['file'])
#     send_message("LOG", "send_to_printer -> Print File contents: \n" + prn_file['raw'])
#     win32print.WritePrinter(printer, prn_file['raw'])
#     send_message("LOG", "send_to_printer -> Close page")
#     win32print.EndPagePrinter(printer)
#     send_message("LOG", "send_to_printer -> Close Doc")
#     win32print.EndDocPrinter(printer)
#     win32print.ClosePrinter(printer)
#     send_message("LOG", "send_to_printer -> print Job done")
#     sys.exit(0)
#
#
# def send_message(msg_type, msg):
#     if msg_type == "LOG":
#         message = '{"log": "' + msg + '"}'
#         sys.stdout.write(struct.pack("I", len(message)))
#         sys.stdout.write(message)
#         sys.stdout.flush()
#
#
# def main():
#     send_message("LOG", "Main -> Started native client")
#     read_input()
#     sys.exit(0)
#
#
# if __name__ == "__main__":
#     main()
#     sys.exit(0)
